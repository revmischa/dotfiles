# Zsh configuration managed by chezmoi

# History configuration
HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
setopt HIST_VERIFY
setopt SHARE_HISTORY
setopt APPEND_HISTORY
setopt INC_APPEND_HISTORY
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_REDUCE_BLANKS
setopt HIST_IGNORE_SPACE

# Options
setopt AUTO_CD              # Change to directory without cd
setopt GLOB_DOTS            # Include dotfiles in globbing
setopt EXTENDED_GLOB        # Extended globbing
setopt NO_BEEP              # No beeping
setopt PROMPT_SUBST         # Allow parameter expansion in prompts

# Completion system (initialize early)
autoload -Uz compinit

# Performance optimization: only check for new completions once per day
# Use faster compinit with security checks disabled for faster startup
if [[ -n ${ZDOTDIR:-$HOME}/.zcompdump(#qN.mh+24) ]]; then
  compinit -d "${ZDOTDIR:-$HOME}/.zcompdump"
else
  compinit -C -d "${ZDOTDIR:-$HOME}/.zcompdump"
fi

# Antidote plugin manager
# Clone antidote if necessary and generate static plugin file
zsh_plugins=${ZDOTDIR:-$HOME}/.zsh_plugins
antidote_dir=${ZDOTDIR:-$HOME}/.antidote

# Improved plugin loading logic
_antidote_needs_update() {
  # Check if static file doesn't exist
  [[ ! -f ${zsh_plugins}.zsh ]] && return 0

  # Check if antidote directory doesn't exist
  [[ ! -d $antidote_dir ]] && return 0

  # Check if plugins.txt is newer than static file
  [[ -f ${zsh_plugins}.txt && ${zsh_plugins}.txt -nt ${zsh_plugins}.zsh ]] && return 0

  return 1
}

# Only regenerate when absolutely necessary
if _antidote_needs_update; then
  # Clone antidote if necessary
  if [[ ! -d $antidote_dir ]]; then
    echo "Installing antidote plugin manager..."
    git clone --depth=1 https://github.com/mattmc3/antidote.git $antidote_dir
  fi

  # Generate static plugin file only if plugins.txt exists
  if [[ -f ${zsh_plugins}.txt ]]; then
    echo "Updating zsh plugins (this may take a moment)..."
    source $antidote_dir/antidote.zsh
    antidote bundle <${zsh_plugins}.txt >${zsh_plugins}.zsh
    echo "Zsh plugins updated successfully!"
  fi
fi

# Source the static plugins file if it exists
[[ -f ${zsh_plugins}.zsh ]] && source ${zsh_plugins}.zsh

# Case-insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'

# Additional completion styling
zstyle ':completion:*' menu select
zstyle ':completion:*' group-name ''
zstyle ':completion:*:descriptions' format '%F{yellow}-- %d --%f'
zstyle ':completion:*:warnings' format '%F{red}-- no matches found --%f'

# Enable completion caching
zstyle ':completion:*' use-cache yes
zstyle ':completion:*' cache-path ${ZDOTDIR:-$HOME}/.zcompcache

# Improve completion performance
zstyle ':completion:*' accept-exact '*(N)'
zstyle ':completion:*' squeeze-slashes true

# Better completion for kill command
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#) ([0-9a-z-]#)*=01;34=0=01'
zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,comm -w -w"

# Tool-specific completion configurations - lazy loaded for performance
# Load bash completion compatibility only when needed
_load_bashcompinit() {
  autoload -U +X bashcompinit && bashcompinit
}

# Lazy completion loading functions
_kubectl_completion() {
  unfunction _kubectl_completion
  _load_bashcompinit
  source <(kubectl completion zsh)
  kubectl $@
}

_aws_completion() {
  unfunction _aws_completion
  _load_bashcompinit
  complete -C aws_completer aws
  aws $@
}

_pip_completion() {
  unfunction _pip_completion
  eval "$(pip completion --zsh)"
  pip $@
}

_pip3_completion() {
  unfunction _pip3_completion
  eval "$(pip3 completion --zsh)"
  pip3 $@
}

_uv_completion() {
  unfunction _uv_completion
  eval "$(uv generate-shell-completion zsh)"
  uv $@
}

_pnpm_completion() {
  unfunction _pnpm_completion
  eval "$(pnpm completion zsh)"
  pnpm $@
}

_terraform_completion() {
  unfunction _terraform_completion
  _load_bashcompinit
  complete -o nospace -C terraform terraform
  terraform $@
}

_tofu_completion() {
  unfunction _tofu_completion
  _load_bashcompinit
  complete -o nospace -C tofu tofu
  tofu $@
}

# Create lazy-loading aliases for completion-heavy tools
command -v kubectl >/dev/null 2>&1 && compdef _kubectl_completion kubectl
command -v aws >/dev/null 2>&1 && compdef _aws_completion aws
command -v pip >/dev/null 2>&1 && compdef _pip_completion pip
command -v pip3 >/dev/null 2>&1 && compdef _pip3_completion pip3
command -v uv >/dev/null 2>&1 && compdef _uv_completion uv
command -v pnpm >/dev/null 2>&1 && compdef _pnpm_completion pnpm
command -v terraform >/dev/null 2>&1 && compdef _terraform_completion terraform
command -v tofu >/dev/null 2>&1 && compdef _tofu_completion tofu

# Load cargo completion only if rust is available and the zsh completion exists
if command -v rustc >/dev/null 2>&1; then
  for toolchain_dir in ~/.rustup/toolchains/*/share/zsh/site-functions(N); do
    fpath=($toolchain_dir $fpath)
    autoload -Uz _cargo
    compdef _cargo cargo
    break
  done
fi

# Docker completion styling
if command -v docker >/dev/null 2>&1; then
  zstyle ':completion:*:*:docker:*' option-stacking yes
  zstyle ':completion:*:*:docker-*:*' option-stacking yes
fi

# Key bindings for history substring search
# These will be available after the plugins are loaded
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down
bindkey '^P' history-substring-search-up
bindkey '^N' history-substring-search-down

# Load aliases
[[ -f "$HOME/.aliases" ]] && source "$HOME/.aliases"

# Load git aliases
[[ -f "$HOME/.config/gitaliases.zsh" ]] && source "$HOME/.config/gitaliases.zsh"

# Load local configuration
[[ -f "$HOME/.zshrc.local" ]] && source "$HOME/.zshrc.local"

# Environment variables
export EDITOR="nvim"
export VISUAL="$EDITOR"

# Development paths
export PATH="$HOME/.local/bin:$PATH"
export PATH="$HOME/bin:$PATH"
# macOS specific configuration
export PATH="/opt/homebrew/bin:$PATH"
export PATH="/usr/local/bin:$PATH"

# Homebrew - lazy load for faster startup
_load_brew() {
  if command -v brew >/dev/null 2>&1; then
    eval "$(brew shellenv)"
  fi
}

# Only load brew environment if we're going to use brew commands
if command -v brew >/dev/null 2>&1; then
  alias brew='_load_brew && unalias brew && brew'
fi

# Node.js version manager - completely lazy load for faster startup
export NVM_DIR="$HOME/.nvm"

# Only create lazy loading if NVM exists but don't load it
if [[ -s "$NVM_DIR/nvm.sh" ]]; then
  # Function to load NVM on first use
  _load_nvm() {
    unset -f nvm node npm npx
    source "$NVM_DIR/nvm.sh"
    [[ -s "$NVM_DIR/bash_completion" ]] && source "$NVM_DIR/bash_completion"
  }
  
  # Create lazy loading functions (not aliases to avoid conflicts)
  nvm() { _load_nvm && nvm "$@"; }
  node() { _load_nvm && node "$@"; }
  npm() { _load_nvm && npm "$@"; }
  npx() { _load_nvm && npx "$@"; }
fi

# pnpm
export PNPM_HOME="$HOME/Library/pnpm"
if [[ -n "$PNPM_HOME" ]]; then
  case ":$PATH:" in
    *":$PNPM_HOME:"*) ;;
    *) export PATH="$PNPM_HOME:$PATH" ;;
  esac
fi
# pnpm end

# Rust
[[ -f "$HOME/.cargo/env" ]] && source "$HOME/.cargo/env"

# Python virtual environments - lazy load
export WORKON_HOME="$HOME/.virtualenvs"
if [[ -f "/usr/local/bin/virtualenvwrapper.sh" ]]; then
  _load_virtualenvwrapper() {
    source "/usr/local/bin/virtualenvwrapper.sh"
  }
  # Load virtualenvwrapper only when needed
  workon() { _load_virtualenvwrapper && unfunction workon && workon "$@"; }
  mkvirtualenv() { _load_virtualenvwrapper && unfunction mkvirtualenv && mkvirtualenv "$@"; }
  rmvirtualenv() { _load_virtualenvwrapper && unfunction rmvirtualenv && rmvirtualenv "$@"; }
fi

# Starship prompt - load immediately as it's needed for every prompt
if command -v starship >/dev/null 2>&1; then
    eval "$(starship init zsh)"
fi

if command -v fzf >/dev/null 2>&1; then
  # Load fzf keybindings and completion on startup so history search works immediately
  eval "$(fzf --zsh)"
fi

# Load zoxide if available
if command -v zoxide >/dev/null 2>&1; then
    eval "$(zoxide init zsh)"
fi
